package net.opentsdb.core;

import net.opentsdb.tsd.QueryStats;
import java.util.concurrent.TimeUnit;

/**
 * Identical to AggregationIterator except for how it handles edges of a Span.
 *
 *	In the constructor it will skip ahead to a point where each span has a nonzero
 * value for the next call to next().
 *
 * 	In hasNext() it will return false if any span is out of points.
 *
 * 	This solves the problem with the difference function, where diff(A, B)
 * 	was producing spiking values if B did not have values for timestamps that
 *  A had values for around the start and end time of a query.  This caused us to
 *  get a value diff(A, 0) which would set off alerts unnecessarily.
 *  The solution was to shave off points at the boundary where one span didn't have values.
 *
 *  @author Brian Peltz
 */
public class EndpointAligningAggregationIterator extends AggregationIterator {

	public EndpointAligningAggregationIterator(SeekableView[] iterators, long start_time, long end_time, Aggregator aggregator, Aggregators.Interpolation method, boolean rate) {
		super(iterators, start_time, end_time, aggregator, method, rate);

		alignFirstTimestamps();
	}

	/**
	 * Goes through timestamp array looking for 0 values.  If it finds a 0 it
	 * checks to see if the next timestamp for that Span is the lowest of all next
	 * timestamps (meaning it will not be zero after the first call to next()).  If it
	 * is not the lowest it calls next() until it is the lowest. Does this until every zero
	 * value has the minimum next timestamp.
	 */
	private void alignFirstTimestamps() {
		int numSeries = iterators.length;
		//check for zeroes
		for(int i = 0; i < numSeries; i++) {
			if(timestamps[i] == 0) {
				long minTime = nextMinimumTimestamp();
				//if next timestamp for this span is not the minimum
				while(timestamps[i + numSeries] > minTime) {
					if(hasNext()) {
						next();
					} else {
						//no more data points so we're sunk
						break;
					}
					//recalculate min time
					minTime = nextMinimumTimestamp();
				}
			}
		}
	}

	private long nextMinimumTimestamp() {
		//set min as first timestamp
		long minTime = timestamps[iterators.length];
		for(int j = iterators.length; j < timestamps.length; j++) {
			if(timestamps[j] < minTime) {
				minTime = timestamps[j];
			}
		}
		return minTime;
	}

	/**
	 * Modified from AggregationIterator
	 * If any next timestamp is greater than end_time we return false,
	 * so if ANY series is out of DataPoints we don't produce values
	 * @return
	 */
	@Override
	public boolean hasNext() {
		final int size = iterators.length;

		for (int i = 0; i < size; i++) {
			// As long as any of the iterators has a data point with a timestamp
			// that falls within our interval, we know we have at least one next.
			if ((timestamps[size + i] & TIME_MASK) > end_time) {
				//LOG.debug("hasNext #" + (size + i));
				QueryStats.aggregationTimer().update(aggregationTimeInNanos, TimeUnit.NANOSECONDS);
				QueryStats.interpolationTimer().update(interpolationTimeInNanos, TimeUnit.NANOSECONDS);
				QueryStats.downSampleTimer().update(downsampleTimeInNanos, TimeUnit.NANOSECONDS);
				QueryStats.moveToNext().update(moveToNextTimeInNanos, TimeUnit.NANOSECONDS);

				LOG.debug("Total aggregationTime=" + (aggregationTimeInNanos / (1000 * 1000)) + "ms.");
				LOG.debug("Total interpolationTime=" + (interpolationTimeInNanos / (1000 * 1000)) + "ms.");
				LOG.debug("Total downSampleTime=" + (downsampleTimeInNanos / (1000 * 1000)) + "ms.");
				LOG.debug("Total moveToNextTime=" + (moveToNextTimeInNanos / (1000 * 1000)) + "ms.");
				//LOG.debug("No hasNext (return false)");
				return false;
			}
		}
		return true;
	}
}
